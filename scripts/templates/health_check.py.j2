#!/usr/bin/env python3
"""
Health Check Endpoint for Raspberry Pi 5 Node - {{ node_id }}
Sprint 7: Pilot Deployment & Validation
"""

import json
import time
import psutil
import subprocess
from http.server import HTTPServer, BaseHTTPRequestHandler
from datetime import datetime
from pathlib import Path

class HealthCheckHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/health':
            self.handle_health_check()
        elif self.path == '/metrics':
            self.handle_metrics()
        else:
            self.send_error(404, "Not Found")
    
    def handle_health_check(self):
        """Basic health check endpoint."""
        try:
            health_data = {
                'status': 'healthy',
                'timestamp': datetime.utcnow().isoformat() + 'Z',
                'node_id': '{{ node_id }}',
                'uptime_seconds': time.time() - psutil.boot_time(),
                'service_status': self.check_service_status(),
                'system': {
                    'cpu_percent': psutil.cpu_percent(interval=1),
                    'memory_percent': psutil.virtual_memory().percent,
                    'disk_percent': psutil.disk_usage('/').percent
                }
            }
            
            # Check if any critical issues
            if (health_data['system']['memory_percent'] > 90 or 
                health_data['system']['disk_percent'] > 95 or
                health_data['service_status'] != 'active'):
                health_data['status'] = 'degraded'
            
            self.send_json_response(health_data, 200)
            
        except Exception as e:
            error_data = {
                'status': 'error',
                'timestamp': datetime.utcnow().isoformat() + 'Z',
                'error': str(e)
            }
            self.send_json_response(error_data, 500)
    
    def handle_metrics(self):
        """Detailed metrics endpoint."""
        try:
            metrics_data = {
                'timestamp': datetime.utcnow().isoformat() + 'Z',
                'node_id': '{{ node_id }}',
                'system': {
                    'cpu': {
                        'percent': psutil.cpu_percent(interval=1),
                        'count': psutil.cpu_count(),
                        'load_avg': list(psutil.getloadavg())
                    },
                    'memory': {
                        'total': psutil.virtual_memory().total,
                        'available': psutil.virtual_memory().available,
                        'percent': psutil.virtual_memory().percent,
                        'used': psutil.virtual_memory().used
                    },
                    'disk': {
                        'total': psutil.disk_usage('/').total,
                        'used': psutil.disk_usage('/').used,
                        'free': psutil.disk_usage('/').free,
                        'percent': psutil.disk_usage('/').percent
                    },
                    'network': self.get_network_stats(),
                    'temperature': self.get_cpu_temperature()
                },
                'service': {
                    'status': self.check_service_status(),
                    'uptime': self.get_service_uptime()
                },
                'sensors': self.check_sensor_status()
            }
            
            self.send_json_response(metrics_data, 200)
            
        except Exception as e:
            error_data = {
                'timestamp': datetime.utcnow().isoformat() + 'Z',
                'error': str(e)
            }
            self.send_json_response(error_data, 500)
    
    def check_service_status(self):
        """Check federated client service status."""
        try:
            result = subprocess.run(
                ['systemctl', 'is-active', 'federated-client-{{ node_id }}'],
                capture_output=True, text=True, timeout=5
            )
            return result.stdout.strip()
        except:
            return 'unknown'
    
    def get_service_uptime(self):
        """Get service uptime in seconds."""
        try:
            result = subprocess.run([
                'systemctl', 'show', 'federated-client-{{ node_id }}',
                '--property=ActiveEnterTimestamp', '--value'
            ], capture_output=True, text=True, timeout=5)
            
            if result.returncode == 0 and result.stdout.strip():
                from datetime import datetime
                start_time = datetime.fromisoformat(result.stdout.strip().replace(' UTC', '+00:00'))
                return (datetime.now(start_time.tzinfo) - start_time).total_seconds()
            return 0
        except:
            return 0
    
    def get_network_stats(self):
        """Get network interface statistics."""
        try:
            stats = psutil.net_io_counters()
            return {
                'bytes_sent': stats.bytes_sent,
                'bytes_recv': stats.bytes_recv,
                'packets_sent': stats.packets_sent,
                'packets_recv': stats.packets_recv
            }
        except:
            return {}
    
    def get_cpu_temperature(self):
        """Get CPU temperature (Pi-specific)."""
        try:
            with open('/sys/class/thermal/thermal_zone0/temp', 'r') as f:
                temp_raw = int(f.read().strip())
                return temp_raw / 1000.0
        except:
            return None
    
    def check_sensor_status(self):
        """Check sensor connectivity status."""
        sensor_status = {}
        
        # Check Sense HAT
        try:
            from sense_hat import SenseHat
            sense = SenseHat()
            temp = sense.get_temperature()
            sensor_status['sense_hat'] = {
                'status': 'connected',
                'temperature': temp
            }
        except:
            sensor_status['sense_hat'] = {'status': 'disconnected'}
        
        # Check ADXL345
        try:
            import board
            import busio
            import adafruit_adxl34x
            
            i2c = busio.I2C(board.SCL, board.SDA)
            accelerometer = adafruit_adxl34x.ADXL345(i2c)
            x, y, z = accelerometer.acceleration
            
            sensor_status['adxl345'] = {
                'status': 'connected',
                'acceleration': {'x': x, 'y': y, 'z': z}
            }
        except:
            sensor_status['adxl345'] = {'status': 'disconnected'}
        
        return sensor_status
    
    def send_json_response(self, data, status_code):
        """Send JSON response."""
        response_json = json.dumps(data, indent=2)
        
        self.send_response(status_code)
        self.send_header('Content-Type', 'application/json')
        self.send_header('Content-Length', str(len(response_json)))
        self.end_headers()
        self.wfile.write(response_json.encode('utf-8'))
    
    def log_message(self, format, *args):
        """Override to reduce log noise."""
        pass

def main():
    """Start health check server."""
    server_address = ('', 8081)
    httpd = HTTPServer(server_address, HealthCheckHandler)
    
    print(f"Health check server starting on port 8081 for node {{ node_id }}")
    print("Endpoints:")
    print("  /health  - Basic health status")
    print("  /metrics - Detailed system metrics")
    
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("\nShutting down health check server...")
        httpd.shutdown()

if __name__ == '__main__':
    main()
